# 20210908 가비지 컬렉션

## 메모리의 생명 주기

1. 필요한 메모리 할당
2. 할당된 메모리 사용(읽기, 쓰기)
3. 해당 메모리가 필요 없어지면 해제

<br>

JS는 매니지드 언어, GC가 메모리를 관리

가비지 콜렉션(GC) : 자동 메모리 관리 형식

메모리 할당을 모니터링, 할당된 메모리 셀이 더이상 필요하지 않은 시점을 확인하여 할당 해제

<br>

### 참조 (Reference)

가비지 콜렉션 알고리즘에서의 핵심 개념은 참조.

A라는 메모리를 통해 B라는 메모리에 접근할 수 있다면.

B는 A에 참조된다.라고 함

<br>

### 참조-세기(Reference-counting) 알고리즘

'더 이상 필요없는 객체'를 '**어떤 다른 객체도 참조하지 않는 객체**' 라고 정의

즉, 특정 객체를 참조하는 객체가 하나도 없다면, 그 객체에 대해 가비지 컬렉션을 수행

<br>

아무 객체도 참조하지 않는다는 것은

애초에 메모리에 직접 접근하는 것 외엔 접근할 방법이 없다는 뜻이므로 make-sense함

<br>

문제점. 두 객체가 서로를 참조하면 문제가 발생.

어느 함수에서 서로 참조를 하는 두 객체가 있다면,

함수가 종료되면 메모리가 회수되어야 하지만,

함수가 종료되도 메모리 회수가 되지 않음.

<br>

### Mark-and-sweep 알고리즘

'더 이상 필요없는 객체'를 '**닿을 수 없는 객체**'로 정의.

root 객체의 집합을 가짐(js에서는 전역 변수를 의미)

<br>

주기적으로 가비지 콜렉터는 root로부터 시작해서,

root가 참조하는 객체들, root가 참조하는 객체가 참조하는 객체들. 쭉쭉쭉 읽어서 접근할 수 있는 객체라고 표시(Mark).

그 후, 접근할 수 없는 객체가 있다면, 가비지 컬렉션을 수행

함수 내의 순환 참조하던 객체들도 roots로 부터 '닿을 수 없는 객체'이므로 가비지 컬렉션이 수행될 수 있음

<br>

**동작 방식**

1. Mark

   객체가 생성될 때마다 mark bit가 0(false)로 설정

   mark 단계에서 모든 접근 가능한 객체의 mark bit가 1(true)로 설정

2. Sweep

   mark 단계 이후 mark bit가 여전히 0(false)이면 '닿을 수 없는 객체'이므로 가비지 콜렉터가 수집해 메모리에서 해제됨

<br>

#### 가비지 컬렉션 최적화 기법

- **generational collection(세대별 수집)**

  객체를 '새로운 객체’와 '오래된 객체’로 나눔.

  대부분의 객체는 생성 이후 제 역할을 빠르게 수행하고 금방 쓸모가 없어짐

  이런 객체를 '새로운 객체’로 구분. 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거합니다. 일정 시간 이상 동안 살아남은 객체는 '오래된 객체’로 분류하고, 가비지 컬렉터가 덜 감시.

- **incremental collection(점진적 수집)**

  방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark 하는데 상당한 시간이 소모될 것.

  가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려질 것. 자바스크립트 엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행합니다. 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있습니다.

- **idle-time collection(유휴 시간 수집)**

  가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행합니다.
